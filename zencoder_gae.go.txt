package zencoder_gae

import (
	"appengine"
	"appengine/urlfetch"
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"time"
)

const (
	DEFAULT_ZENCODER_API_ENDPOINT = "https://app.zencoder.com/api/v2/jobs"
	DEFAULT_RESPONSE_TYPE         = "application/json"
)

type Client struct {
	ApiKey       string
	ApiEndpoint  string
	ResponseType string
	Timeout      int
}

type Options struct {
	ApiKey       string
	ApiEndpoint  string
	ResponseType string
	Timeout      int
}

type Response map[string]interface{}

type Input struct {
	Input string `json:"input"`
}

func NewInput(input string) *Input {
	return &Input{
		Input: input,
	}
}

type Outputs struct {
	Outputs []map[string]interface{} `json:"outputs"`
}

func NewOutputs(outputs []map[string]interface{}) *Outputs {
	return &Outputs{
		Outputs: outputs,
	}
}

type RequestBody struct {
	Input   *Input
	Outputs *Outputs
}

func NewRequestBody(Input input, Outputs outputs) *RequestBody {
	return &RequestBody{
		Input:   input,
		Outputs: outputs,
	}
}

func NewClient(options Options) *Client {
	if options == nil {
		err := fmt.Errorf("error: cannot init Zencoder client without Options")
		return nil, err
	}
	if len(options.ApiKey) == 0 {
		err := fmt.Errorf("error: must supply ApiKey option to init")
		return nil, err
	}
	responseType := DEFAULT_RESPONSE_TYPE
	if len(options.ResponseType) > 0 {
		if options.ResponseType == "application/xml" {
			responseType = "application/xml"
		} else {
			err := fmt.Errorf("error: unsupported response type. response type may be application/json (default) or application/xml")
			return nil, err
		}
	}
	timeout := 30
	if options.Timeout > 0 {
		timeout = options.Timeout
	}
	apiEndpoint := DEFAULT_ZENCODER_API_ENDPOINT
	if len(options.ApiEndpoint) > 0 {
		apiEndpoint = options.ApiEndpoint
	}

	return &Client{
		ApiKey:       options.ApiKey,
		ApiEndpoint:  apiEndpoint,
		ResponseType: responseType,
		Timeout:      timeout,
	}
}

func (c *Client) Zencode(input Input, output Output) (*Response, error) {
	requestBody := NewRequestBody(Input, Outputs)
	if inputStr, err := json.Marshal(requestBody); err != nil {
		return nil, err
	} else {
		if req, err := http.NewRequest("POST", c.ApiEndpoint, bytes.NewBuffer(inputStr)); err != nil {
			return nil, err
		} else {
			req.Header.Add("Content-Type", c.ResponseType)
			req.Header.Add("Zencoder-Api-Key", c.ApiKey)

			tr := &urlfetch.Transport{Context: ctx, Deadline: time.Duration(c.Timeout) * time.Second}

			if res, err := tr.RoundTrip(req); err != nil {
				return nil, err
			} else {
				defer res.Body.Close()

				strResp, _ := ioutil.ReadAll(res.Body)
				if res.StatusCode >= 400 {
					return nil, fmt.Errorf("error: %s", string(strResp))
				}

				var response Response
				json.Unmarshal(strResp, &response)

				return response, nil
			}
		}
	}
}
